# -*- coding: utf-8 -*-
"""StringAbstract.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LtaiSBa8vX-fvpqX_PSck2QzRPWY8bat
"""

# Final Code

# solution.py

def solution(s):
    answer = 0

    # set the answer as the length of s
    answer = len(s)
    answer_str = ""
   
    # working string
    string = ""

  #debugging
    this_str = ""
    next_str = ""

    # temporary string to store the abstract string by the length of string
    temp_str = ""
    # store the rest of the substring
    tail = ""
  
    # how many substring is in the string
    counter = 1

    #flag for checking the last input or not
    flag = False

    # for loop for the length of strings from 1 to 1000
    for i in range(1,int(len(s)/2) + 1):

      # reset the flag
      flag = False

      #length of string named s
      this_str = s[0:i]

      # current index
      curr_index = 0

      #test
      print( "length of string is " + "{}".format(i) + " string is "+ this_str +"\n")

      for x in range(len(this_str), len(s), len(this_str)):

  #print("{}".format(x)+"th trial" )
        curr_index = x + len(this_str)
        substring = s[x:curr_index]
  #print("{}".format(x)+"th trial after" )
        print("current string is: " + substring)
        
        # substring matches
        if this_str == substring:
          print("string matches! ") #debug
          counter += 1 
          # if this is not the last character
          if x + len(this_str) != len(s):
          #if x != len(s):
            #print("continue! " + "{}".format(x) + " "+"{}".format(len(s)))
            continue
          # Last char case.
          else:             
            # update the temp_str
            #temp_str = temp_str + "{}".format(counter)+ string + "{}".format(x) 
            temp_str = temp_str + "{}".format(counter)+ substring #+ "{}".format(x)

            # check the false to indicate that this is the last string
            flag = True 

        # substring does not match
               
        else:
          print("string does not matches! ")   # debug
          print("before temp_str: " + temp_str )
          # if there are more than one matching
          if counter != 1:
            # update the temp_str
            #temp_str = temp_str + "{}".format(counter)+ this_str
            temp_str = temp_str + "{}".format(counter) + this_str
          # just one string 
          else:
            temp_str += this_str
          print("after temp_str: " + temp_str)
        
        print("case "+ "i: " "{}".format(i) + " x: " + "{}".format(x) +" temp_string: " + temp_str + " this_str: " + this_str + " temp_str: " + temp_str + " substring:"+ substring +" counter: " + "{}".format(counter))
        #print("temp_str: " + temp_str )
        # change the working string
        this_str = substring
        tail = substring
        # reset the counter
        counter = 1
###########
      # check there is a next line or not. 
      if flag == False:
        """
        #it does not work using index version 
        print("FLAG IS FALSE! SO ADD: " + s[curr_index-1:] )
        print("{}".format(curr_index-1) + "\n")
        temp_str += s[curr_index-1:]
        """
        print("FLAG IS FALSE! SO ADD: " + tail )
        temp_str += tail
        print(temp_str)


##########

  #      print("Loop2 :" + "{}".format(x) +" temp_string: " + temp_str + " this_str: " + this_str)

 #     print("Loop1 :" + "{}".format(x) +" temp_string: " + temp_str + " this_str: " + this_str)

      #check the min length
      if answer > len(temp_str):
        answer = len(temp_str)
        answer_str = temp_str
        print("this is the answer: " +"{}".format(answer)  )
        print(answer_str + "\n")

      #reset the temp_str
      temp_str = ""


    return answer
 
solution("aabbaccc")
